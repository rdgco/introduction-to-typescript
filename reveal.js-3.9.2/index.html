<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>reveal.js</title>

	<link rel="stylesheet" href="css/reset.css">
	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/beige.css">

	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="lib/css/monokai.css">

	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
		document.getElementsByTagName('head')[0].appendChild(link);
	</script>
</head>

<body>
	<div class="reveal">
		<div class="slides">

      <section>
        <h2>Typescript</h2>
        <ul>
          <li>Typscript is a superset of Javascript. </li>
          <li>Typescript is "transpiled" into Javascript.</li>
          <li>Validation happens at transpile time, not runtime.</li>
        </ul>
      </section>

			<section>
				<h3>Primitive Types</h3>
				<p>
					Each primitive variable in typescript has one of the following associated types.
					<ul>
            <li>any</li>
						<li>number</li>
						<li>string</li>
						<li>boolean</li>
						<li>enum</li>
						<li>void</li>
						<li>null</li>
						<li>any</li>
						<li>undefined</li>
					</ul>
				</p>
			</section>

      <section>
        <h3>User Defined Types</h3>
        <p>
          Types can be combined and arranged in more complex user defined structures. For example:
          <pre>
            <code data-trim>
              type person = {
                firstName: string,
                lastName: string
              };
              let obj: person = {
                  firstName: 'Bob',
                  lastName: 'Roberts'
              };
            
              console.log(obj);
            </code>
          </pre>
        </p>
      </section>


			<section>
				<h2>Defining Variables with Implicit Types</h2>
        <p>
				The let keyword, is used to define a variable in typescript. This variable scope will be limited
        to the file or module it appears in.
        </p>
				<pre>
					<code data-trim>
            // typescript implicitly defines anExampleVariable as type string.
            let anExampleVariable = "Hello World";

            anExampleVariable = "GoodBye";
            
            // typescript will raise an error here, because a number can
            // not be assigned to a string.
            anExampleVariable = 10; 
					</code>
				</pre>
			</section>



			<section>
				<h2>Constant Variables</h2>
				<p>
					Declaring a variable with const, will force the compiler to prevent assigning another
          value to that variable.
				</p>
				<pre>
					<code data-trim>
						const x = 10;
						console.log(x);
						# this next line will fail to compile.
						# constant variables can not be modified.
						x = 20;
					</code>
				</pre>
			</section>

      <section>
				<h2>Limitations of Constant Variables</h2>
				<p>
          The object that a variable is assigned to can be changed however.
				</p>
				<pre>
					<code data-trim>
            const x = {
              firstName: 'Bob',
              lastName: 'Dylan',
            }
            console.log(x);

            x.lastName = 'Seger';  // This is OK.

            // This is Not OK
            x = {
              firstName: 'Bob',
              lastName: 'Barker'
            }
					</code>
				</pre>
			</section>

      <section>
        <h3>Types vs Javascript Object Types</h3>
        <p>
          Javascript defines Objects to represent the primitive types. These names start with an upper case letter.
          Don't use these for typescript types as it can lead to confusion.
          <ul>
            <li>Number</li>
            <li>string</li>
            <li>Boolean</li>
            <li>etc...</li>
          </ul>
        </p>
      </section>

			<section>
				<h3>Type: number</h3>
				<p>
					Types can be explicitly defined for variables. This example specifies that x is of type "number"
					explicitly.
				</p>
				<pre>
					<code data-trim>
            let x:number = 10;
            x = 20;

            // the type of y is implicitly set to number.
            let y = x;
            console.log(y);
					</code>
				</pre>
			</section>

			<section>
				<h3>Floating Point Numbers</h3>
				Numbers are represented by floating point data in Typescript. So both whole numbers and
				numbers with floating point values are represented by the number datatype.
				<pre>
					<code data-trim>
						let x:number = 20.5;
						let y:number = 3;
						console.log(x);
						console.log(x * 3);
					</code>
				</pre>
			</section>

			<section>
				<h3>Strings</h3>
				String type variables represent one or more characters in a terminated sequence.
				<pre>
					<code data-trim>
						let town:string = "Denver";
						console.log(x);

						let letter:string = "C"
						console.log(letter);
					</code>
				</pre>
			</section>


			<section>
				<h3>String Methods</h3>
				All of the javascript string methods are available with typescript strings.
				<pre>
					<code data-trim>
						const firstName = "Bol";
						const lastName = "Bol";
						const fullName = firstName.concat(lastName);
						console.log(fullName); // -> Bol Bol

						let length: number = fullName.length
						console.log(length); // -> 7
					</code>
				</pre>
			</section>

			<section>
				<h3>Boolean</h3>
				A boolean typed variable can represent one of either 'true' or 'false'.
				<pre>
					<code data-trim>
						const on = true;
						const off = false;
						const lightState = on;
						if (lightState) {
							console.log("The light is on");
						} else {
							console.log("The light is not on");
						}
					</code>
				</pre>
			</section>

			<section>
				<h3>Enum</h3>
				<p>
					An enum represents a possible set of values that a variable can be assigned.
				</p>
				<pre>
					<code data-trim>
						enum Direction {
							North = 'North',
							East = 'East',
							South = 'South',
							West = 'West',
						}
						console.log(Direction.North); // --> North
						let dir: Direction = East;
						console.log(dir); // -> East
					</code>
				</pre>
			</section>

			<section>
				<h3>Null</h3>
				<p>
					null is a type that can only hold the value null.
				</p>
				<pre>
					<code data-trim>
            let s: null = null;
            console.log(s); // -> null
            if (s === null) {
              console.log("s is set to null");
            }
            s = 10; // Error because number is not of type null.
					</code>
				</pre>
			</section>

      <section>
        <h3> Implicit type is 'any' when assigning to null</h3>

        <pre>
          <code data-trim>
            let s = null;  // s type is implicitly set to any
            s = 10;
            s = 'ten';  // ok because s is of type any
          </code>
        </pre>
      </section>

      <section>
				When using the recommended --strictNullChecks flag, only any and null can be assigned to null.
				<pre>
          <code data-trim>
            let s: any = null;
            console.log(s);  // --> null
            s = 30; // s can be assigned to any type of value.
            let n: number = null; // compile error, type null is not assignable to type number.
          </code>
				</pre>
			</section>

      <section>
        <h3> Allow a typed variable to also be nullable </h3>
        <pre>
          <code data-trim>
            // A pipe between types means one type or the other.
            let s: number | null = null; 
            s = 5;
            s = null;

            // Fails compiling because 'blah' is not a number or null.
            s = 'blah';
          </code>
        </pre>
      </section>

      <section>
				Any
				<p>
          The 'any' type is the wildcard of types. It provides no benefit of typechecking and is essentially what all variables in javascript are defined as.
				</p>
				<pre>
					<code data-trim>
						let hybridArray: any[] = [];
						hybridArray[0] = [1, 2, 3];
						hybridArray[1] = "blah blah";
						hybridArray[2] = true;
						console.log(hybridArray);
					</code>
				</pre>
			</section>

			<section>
				<h3>Array</h3>
				<p>
					Array variables can be assigned to a list of values. The types of the values in
					the list are used to implicitly determine the type of the array if the type isn't specified.
				</p>
				<pre>
					<code data-trim>
						let names: string[] = [];
						names[0] = "Bob";
						names[1] = "Mary";
						console.log(names);
					</code>
				</pre>
			</section>

			<section>
				<h3>Array Initialization with the same types</h3>
				<p>
					Array variables can be assigned to a list of values. The types of the values in
					the list must also be assigned to a type. 
				</p>
				<pre>
					<code data-trim>
						let names = ["Bob", "Mary"]; // names: String[]
						console.log(names);
					</code>
				</pre>
			</section>

      <section>
				<h3>Array Initialization with different types</h3>
				<p>
					Array variables can be assigned to a list of values. The types of the values in
					the list must also be assigned to a type. 
				</p>
				<pre>
					<code data-trim>
            // implicitly defines names: (string | number | boolean)[]
            let names = ["One", "Two", 3, 4, true]; 
            console.log(names);

            // type null is not assignable to type (string | number | boolean)
            names[6] = null; 
					</code>
				</pre>
			</section>

			<section>
				<h3>Tuple</h3>
				<p>
					A tuple is an array like object with a fixed length and types specified for each position.
				</p>
				<pre>
					<code data-trim>
						// Declare a tuple type
						let x: [string, number];

						// Initialize it
						x = ["hello", 10]; // OK

						// Initialize it incorrectly
						x = [10, "hello"]; // Error
					</code>
				</pre>
			</section>

			<section>
				<h3>Variables and Scope</h3>
				<p>
          Variables declared within a block scope are not accessible outside of the scope.
        </p>
				<pre>
					<code data-trim>
            function scope1() {
              let x = 5;
              console.log(x);
            }
            function scope2() {
              console.log(x);     // x is not defined here so this should yield an error.
            }

            scope2();
					</code>
				</pre>
			</section>

      <section>
				<h3>The 'var' keyword</h3>
				<p>
          The var keyword from javascript has some different scoping rules than let and const.
          This is an obsolete way of declaring variables in Javascript.
				</p>
      </section>

			<section>
				<h3>Functions</h3>
				<p>
					A typescript function can optionally have one or more parameters that are assigned to
					values by the caller and can return 1 or more values to the caller.
					This function does not return a value or take parameters.
				</p>
				<pre>
					<code data-trim>
            function logsomething() {
              console.log("something");
            }
            logsomething();
					</code>
				</pre>
			</section>

			<section>
				Function Parameters
				<pre>
					<code data-trim>
            function greet(name: String, timesnumber) {
              for (let t = 0; t < times; t++) {
                console.log(`Hello ${name}`);
              }
            }
            greet("Angelina", 10); // OK

            greet(10); // Compile error, number is not compatible with string.
					</code>
				</pre>
			</section>


			<section>
				Function Parameters Default Values
				<pre>
					<code data-trim>
            function greet(name: String, times: number = 1) {
              for (t = 0; t < times; t++) {
                console.log(`Hello ${name}`);
              }
            }
            greet("Angelina");
					</code>
				</pre>
			</section>

			<section>
				Function Return Values
				<pre>
					<code data-trim>
						function double(value: number): number {
							return value * 2;
						}

						let doubled = double(10);
						console.log(doubled);
					</code>
				</pre>
			</section>

      <section>
				Compile Validation of Function Return Values
				<pre>
					<code data-trim>
            function double(value: number): number {
              return value * 2;
            }
            // string is not compatible with number.
            let number: string = double(10); 
					</code>
				</pre>
			</section>

			<section>
				<h3> Typescript Function Shortcuts </h3>
				<p>
					A one line function that returns a value has shorthand notation.
				</p>
				<pre>
        <code data-trim>
          const double = (value: number): number => value * 2

          let doubled = double(10);
          console.log(doubled);
        </code>
				</pre>
			</section>

      <section>
        <h3> Typescript Function Shortcut with Paranthesis </h3>
        <pre>
          <code data-trim>
            const embed = (value: string): string => (
              `The value you entered was: ${value}.`
            )

            const response = embed('This is my final answer.');

            // -> The value you entered was: This is my final answer.
            console.log(response); 
          </code>
        </pre>
      </section>


			<section>
				<h3> Typescript Function Shortcuts for MultiLine </h3>
				<p>
					A one line function that returns a value has shorthand notation.
				</p>
				<pre>
					<code data-trim>
						const double = (value: number): number {
							console.log("calling this function");
							return value * 2;
						}

						let doubled = double(10);
						console.log(doubled);
					</code>
				</pre>
			</section>

			<section>
				Classes
				<p>
					Classes were introduced to Javascript in ECMA Script.
        </p>
				<pre>
					<code data-trim>
            class Meetup {
              title: string;
              description: string;

              constructor(title, description) {
                this.title = title;
                this.description = description;
              }

              public toString(): string {
                return `Class Title: ${title}\nDescription:\n${description}.`;
              }

            }

            let m = new Meetup("Introduction to Typescript",
              "A high level overview of Typescript Language Concepts.");

            console.log(m);
					</code>
				</pre>
			</section>

			<section>
				Interfaces
				<b>
					Interfaces define the structure of the type without using a class.
				</b>
				<pre>
					<code data-trim>
            interface Event {
              title: string;
              description: string;
              toString();
            }
					</code>
				</pre>
			</section>

			<section>
				<h2>Implementing an interface</h2>
				<b>
					A class can implement an interface.
				</b>
				<pre>
					<code data-trim>
            class Workshop implements Event {
              title: string;
              description: string;
              instructor: string;  // not part of the interface

              constructor(title, description, instructor) {
                this.title = title;
                this.description = description;
                this.instructor = instructor;
              }

              public toString(): string {
                return `Instructor: #{instructor}\nClass Title: ${title}\nDescription:\n${description}.`;
              }
            }

            let e:Event = new Meetup("Introduction to Typescript",
              "A high level overview of Typescript Language Concepts.");
            let m:Meetup = new Meetup(("Introduction to Javascript",
            "A high level overview of Javascript Language Concepts."))
            console.log(e);
            console.log(m);
					</code>
				</pre>
			</section>

			<section>
				<h2>Modules</h2>
				<p>
					Each file in typescript represents 1 module. A module is a scoped namespace.
					In order for one module to access another module, symbols must be explicitly
					imported.
				</p>
				<code data-trim>
					import greet from './Greet';

					greet.sayHi('Brad');
				</code>
			</section>

			<section>
				<h2>Default and Other exports</h2>
				<p>
					Each module can export multiple objects, but only one default.
				</p>
				<code data-trim>
					export function f1() {
						// do something
					}

					export default function f2() {
						// do something else
					}
				</code>
			</section>

			<section>
				<h2>Default and Other exports</h2>
				<p>
					The default import can be on the same line as the non-default imports.
				</p>
				<code data-trim>
				 	import f2, { f1 } from module;
				</code>
			</section>

      <section>
				<h2>Generics</h2>
				<p>
					Generics are defined by a set of type variables as part of a declaration.
					A type variable is a placeholder for a type. Shown here in this
					identity function as &lt;T&gt;. This means the function can be called with
          any type and it will return an value with the same type.
				</p>
				<pre>
					<code data-trim>
            function identity&lt;T&gt;(value: T): T {
              return value;
            }
            let v = 22;
            let y = identity<number>(v);
            console.log(y);
					</code>
				</pre>
			</section>

      <section>
				<h2>Generics: Part 2</h2>
				<p>
          Typechecking is performed based on the type that is passed in for the type variable.
				</p>
				<pre>
					<code data-trim>
            function identity &lt;T&gt;(value: T) : T {
              return value;
            }
            
            console.log(identity&lt;Number&gt;(1)) // 1
            
            let value = 10;
            // the next line fails, because the return type for identify will be
            // a number.
            let message: string = identity&ltnumber&gt(value);
					</code>
				</pre>
			</section>

      <section>
        <h2> Generics: What are they Good For?</h2>
        <p>
        Generics are used to define data structures and objects that share the same methods
        and even logic, however the types that they work with can be different. The Map class
        has 2 type variables, one for the type of key and one for the type of value.
        </p>
        <pre>
          <code data-trim>
            class Person {
              name: string;
              constructor(name: string) {
                  this.name = name;
              } 
            }
            let directory = new Map&lt;string, Person&gt;();
            directory.set('Ryan', new Person('Ryan'));
            console.log(dictionary.get('Ryan'));
            // This wont compile because the second parameter is not of type
            // Person.
            directory.set('Ryan', 'Ryan'); 
          </code>
        </pre>
      </section>


      <section>
        <h2> Structural Typing vs. Nominal Typing</h2>

        <p>
          Typescript is different from many other strongly typed languages in the way it determines the type compatibility of different variables.
          This is because javascript is built on Duck Typing which considers two objects of the same type if they both implement the same methods.
        </p>
        <p>
          This is best described here:
          <a href="https://www.typescriptlang.org/docs/handbook/type-compatibility.html">typescriptlang.org Type Compatibility</a>
        </p>
      </section>
		</div>
	</div>

	<script src="js/reveal.js"></script>

	<script>
		// More info about config & dependencies:
		// - https://github.com/hakimel/reveal.js#configuration
		// - https://github.com/hakimel/reveal.js#dependencies
		Reveal.initialize({
			hash: true,
			dependencies: [
				{ src: 'plugin/markdown/marked.js' },
				{ src: 'plugin/markdown/markdown.js' },
				{ src: 'plugin/highlight/highlight.js' },
				{ src: 'plugin/notes/notes.js', async: true }
			]
		});
	</script>
</body>

</html>